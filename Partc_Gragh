// =========================================================
// PART C: WORLD NAVIGATOR (Graphs)
// =========================================================

bool WorldNavigator::pathExists(int n, vector<vector<int>>& edges, int source, int dest) {
    // TODO: Implement path existence check using BFS or DFS
    // edges are bidirectional
    if (source == dest) return true;
    // Build adjacency list
    vector<vector<int>> adj(n);
    for (auto &e : edges) {
        adj[e[0]].push_back(e[1]);
        adj[e[1]].push_back(e[0]);
    }

    vector<bool> visited(n, false);
    queue<int> q;

    q.push(source);
    visited[source] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int v : adj[u]) {
            if (!visited[v]) {
                if (v == dest) return true;
                visited[v] = true;
                q.push(v);
            }
        }
    }
    return false;

}

long long WorldNavigator::minBribeCost(int n, int m, long long goldRate, long long silverRate,
                                       vector<vector<int>>& roadData) {
    // TODO: Implement Minimum Spanning Tree (Kruskal's or Prim's)
    // roadData[i] = {u, v, goldCost, silverCost}
    // Total cost = goldCost * goldRate + silverCost * silverRate
    // Return -1 if graph cannot be fully connected
    vector<pair<long long, pair<int,int>>> edges;

    for (auto &r : roadData) {
        long long cost = r[2] * goldRate + r[3] * silverRate;
        edges.push_back({cost, {r[0], r[1]}});
    }

    sort(edges.begin(), edges.end());

    vector<int> parent(n);
    iota(parent.begin(), parent.end(), 0);

    function<int(int)> find = [&](int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    };

    long long total = 0;
    int cnt = 0;
    // Kruskal's Algorithm
    for (auto &e : edges) { // e = {cost, {u, v}}
        int u = e.second.first;
        int v = e.second.second;

        if (find(u) != find(v)) {
            parent[find(u)] = find(v);
            total += e.first;
            cnt++;
        }
    }

    if (cnt != n - 1) return -1;
    return total;

    }

string WorldNavigator::sumMinDistancesBinary(int n, vector<vector<int>>& roads) {
    // TODO: Implement All-Pairs Shortest Path (Floyd-Warshall)
    // Sum all shortest distances between unique pairs (i < j)
    // Return the sum as a binary string
         // Hint: Handle large numbers carefully
            const long long INF = 1e18;
    vector<vector<long long>> dist(n, vector<long long>(n, INF));

    for (int i = 0; i < n; i++)
        dist[i][i] = 0;

    for (auto &r : roads) {
        dist[r[0]][r[1]] = r[2];
        dist[r[1]][r[0]] = r[2];
    }

    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];

    long long sum = 0;
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
            if (dist[i][j] < INF)
                sum += dist[i][j];

    if (sum == 0) return "0";

    string binary = "";
    while (sum > 0) {
        binary = char('0' + (sum % 2)) + binary;
        sum /= 2;
    }

    return binary;

    
}
